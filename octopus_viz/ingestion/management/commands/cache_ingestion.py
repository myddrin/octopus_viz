import dataclasses
import json
import logging
import os.path
from datetime import datetime
from typing import Self

from django.core.management import BaseCommand
from django.db import transaction, IntegrityError

from ingestion import models


logger = logging.getLogger(__name__)


@dataclasses.dataclass
class FilenameInfo:
    meter_serial: str
    mpan: str
    start_date: str
    end_date: str

    @classmethod
    def from_filename(cls, file_path: str) -> Self:
        filename = os.path.basename(file_path)
        return cls(*filename.split('_'))


@dataclasses.dataclass
class FileData:
    consumption: float
    direction: models.Direction
    energy_type: models.EnergyType
    metric_unit: models.MetricUnit
    interval_start: datetime
    interval_end: datetime

    @property
    def unit_str(self) -> str:
        return f'{self.energy_type.value.lower()}_{self.direction.name.lower()}_{self.metric_unit.value.lower()}'

    @classmethod
    def from_line(cls, line: str) -> Self:
        data = json.loads(line)
        consumption = float(data.pop('consumption'))
        energy_str, direction_str, metric_unit_str = data.pop('unit').split('_')
        energy_type = models.EnergyType[energy_str.upper()]
        direction = models.Direction[direction_str.upper()]
        metric_unit = models.MetricUnit[metric_unit_str.upper()]
        interval_start = datetime.fromisoformat(data.pop('interval_start'))
        interval_end = datetime.fromisoformat(data.pop('interval_end'))
        return cls(
            consumption=consumption,
            energy_type=energy_type,
            direction=direction,
            metric_unit=metric_unit,
            interval_start=interval_start,
            interval_end=interval_end,
        )


class Command(BaseCommand):
    help = 'Ingest data from a cache file generated by the old interface'

    def add_arguments(self, parser):
        parser.add_argument(
            'file_path',
            type=str,
            nargs='+',
            help='The path to the JSON cache file generated by the manual command line',
        )
        parser.add_argument(
            '--create-missing-meter',
            action='store_true',
        )

    def _load_data(self, filename: str) -> list[FileData]:
        data = []
        with open(filename) as fin:
            for line in fin:
                data.append(FileData.from_line(line))
        self.stdout.write(f'  {len(data)} objects loaded from file')
        if not data:
            raise RuntimeError('The file is empty')
        return data

    @classmethod
    def meter_from_filename(cls, file_info: FilenameInfo) -> models.Meter | None:
        try:
            return models.Meter.objects.select_related('mpan').filter(
                serial=file_info.meter_serial,
                mpan__mpan=file_info.mpan,
            )[0]
        except IndexError:
            return None

    def _upsert_meter(self, file_info: FilenameInfo, *, create_meter: bool, first_elem: FileData) -> models.Meter:
        meter = self.meter_from_filename(file_info)
        if meter is not None:
            if meter.metric_unit != first_elem.metric_unit:
                raise RuntimeError(
                    f'Found meter {file_info.meter_serial} but {meter.metric_unit=} vs {first_elem.metric_unit=}',
                )
            if meter.energy_type != first_elem.energy_type:
                raise RuntimeError(
                    f'Found meter {file_info.meter_serial} but {meter.energy_type=} vs {first_elem.energy_type}',
                )
            if meter.mpan.direction != first_elem.direction:
                raise RuntimeError(
                    f'Found meter {file_info.meter_serial} with mpan {file_info.mpan} but {meter.mpan.direction=} vs {first_elem.direction}',
                )
        elif meter is None and not create_meter:
            raise RuntimeError(
                f'Could not find meter {file_info.meter_serial}: use --create-missing-meter or create it',
            )
        elif meter is None:
            self.stdout.write(f'  meter {file_info.meter_serial} not found - creating it')

            # first check if mpan exists
            try:
                mpan = models.MPAN.objects.filter(mpan=file_info.mpan)[0]
            except IndexError:
                self.stdout.write(f'  MPAN {file_info.mpan} is created too')
                mpan = models.MPAN.objects.create(
                    mpan=file_info.mpan,
                    direction=first_elem.direction,
                    api_key=None,
                )
            else:
                if mpan.direction != first_elem.direction:
                    raise RuntimeError(f'Found mpan {file_info.mpan} but {mpan.direction=} vs {first_elem.direction}')

            meter = models.Meter.objects.create(
                serial=file_info.meter_serial,
                energy_type=first_elem.energy_type,
                metric_unit=first_elem.metric_unit,
                mpan=mpan,
            )

        return meter

    def _data_ingestion(self, meter: models.Meter, data: list[FileData]) -> int:
        exp_unit_str = data[0].unit_str

        ingested = 0
        for line, entry in enumerate(data, start=1):
            # Ensure all elements have the same unit
            if exp_unit_str != entry.unit_str:
                # We are in a transaction - all is roll-backed
                raise RuntimeError(
                    f'Found elements with different units at line {line}, {exp_unit_str=} vs {entry.unit_str=}',
                )

            with transaction.atomic():
                try:
                    models.Consumption.objects.create(
                        consumption=entry.consumption,
                        interval_start=entry.interval_start,
                        interval_end=entry.interval_end,
                        meter=meter,
                        rate=None,
                    )
                except IntegrityError:
                    self.stdout.write(f'  skipping {entry} that is already present...')
                else:
                    ingested += 1
        return ingested

    def load_file(self, filepath: str, *, create_missing_meter: bool):
        self.stdout.write(f'Loading information from {filepath}...')
        with transaction.atomic():
            file_info = FilenameInfo.from_filename(filepath)
            data = self._load_data(filepath)
            meter = self._upsert_meter(file_info, create_meter=create_missing_meter, first_elem=data[0])
            ingested = self._data_ingestion(meter, data)
            self.stdout.write(f'Ingested {ingested} objects from {filepath}')

    def handle(self, file_path: list[str], create_missing_meter: bool, **kwargs):
        for filepath in file_path:
            try:
                self.load_file(filepath, create_missing_meter=create_missing_meter)
            except Exception as ex:
                self.stderr.write(f'Failed to load {filepath}')
                self.stderr.write(f'Error: {ex.__class__.__name__}: {ex}')
                logger.exception(f'For {filepath}')
                continue
